#!/bin/bash
#
# Copyright 2015 Olivier van Helden <olivier@van-helden.net>
# Released under GNU Affero GPL v3.0 license
#    http://www.gnu.org/licenses/agpl-3.0.html

# Parses .ini files and load values in bash
#
# LOAD VALUES:
# Put this line in your script, before the first use:
# (pay attention to the dot, do not execute parse directly)
#     . /PATH/TO/ini_parse
# Then, initiate an ini file
#     ini.parse /PATH/TO/YOUR.ini
# And to fetch values in SECTION
#     ini.section.SECTION
# You can repeat ini.parse and ini.section.*
# Values already present will be replaced
# For example
#     ini.section.Default
#     ini.section.Host1
#
# WRITE VALUES:
# To output loaded values in .ini format:
#     ini.write
# To write only a specific section's values:
#     ini.section.SECTION
#     ini.write SECTION
# To fetch all values and output .ini format:
#     ini.load.all
#     ini.write SECTION
#
# MERGE VALUES
# Load values of a section from serveral ini files
#     ini.merge SECTION FILE1 FILE2 [FILE3..]
#     Files are loaded in order provided, overriding previous values
#     Values not defined in next file are kept

shopt -s compat42
[ ! "$TAB" ] && TAB="   "
[ ! "$TMP" ] && TMP=/tmp/$(basename "0" | sed "s/ /_/g").$$
TMPINI=$TMP.ini_parser

trap "{ rm -f $TMPINI.*; ls $TMPINI.* 2>/dev/null; }" EXIT

ini.parse ()
{
    [ ! -f "$1" ] && return 1
    SAVED_IFS=$IFS
    # ini="$(<$1)"                # read the file
    ini=$(cat $1 \
	| sed "s/[[:blank:]]*=[[:blank:]]*/=/g" \
	| sed "s/^[[:blank:]]*;.*//" \
	| sed "s/;[[:blank:]]*$//" \
	| sed "s/;/%%SEMICOLON%%/g" \
	| egrep -v "^[[:blank:]]*;//" \
	| sed "s/^[[:blank:]]*$//" \
	| sed "s/\([{\\$]\)/\\\\\1/g" \
	| sed "s/=\([^\"].*[|{}\\$].*\)\"*$/=\"\\1\"/g" \
	| sed "s/=/%3D/g" \
	| sed "s/%3D/=/"
    )
    ini="${ini//[/\[}"          # escape [
    ini="${ini//]/\]}"          # escape ]
    IFS=$'\n' && ini=( ${ini} ) # convert to line-array
    ini=( ${ini[*]//;*/} )      # remove comments with ;
    ini=( ${ini[*]/\    =/=} )  # remove tabs before =
    ini=( ${ini[*]/=\   /=} )   # remove tabs after =
    ini=( ${ini[*]/\ =\ /=} )   # remove anything with a space around =
    ini=( ${ini[*]/#\\[/\}$'\n'ini.section.} ) # set section prefix
    ini=( ${ini[*]/%\\]/ \(} )    # convert text2function (1)
    ini=( ${ini[*]/=/=\(} )    # convert item to array
    ini=( ${ini[*]/%/ \)} )     # close array parenthesis
    ini=( ${ini[*]/%\\ \)/ \\} ) # the multiline trick
    ini=( ${ini[*]/%\( \)/\(\) \{} ) # convert text2function (2)
    ini=( ${ini[*]/%\} \)/\}} ) # remove extra parenthesis
    ini[0]="" # remove first element
    ini[${#ini[*]} + 1]='}'    # add the last brace
    eval "$(echo "${ini[*]}" \
            | sed -e 's/\\$\\{/\\\${/g' \
              -e 's/%%SEMICOLON%%/;/g' \
              -e 's/%3B/;/g' \
              -e 's/%3D/=/g'
           )"
    ini_cache=$1
    ini_parsed=$1
    IFS=$OLDIFS
}

ini.list.sections () 
{
    rm -f "$TMPINI.sections"
    i=$#
    while [ $i -gt 0 ]
    do
	file=${!i}
	i=$(($i - 1))
	printf "" | cat $file \
	    | grep "^[[:blank:]]*\[[a-zA-Z0-9_]*\]" \
	    | sed "s/;.*//" \
	    | cut -d "[" -f 2 | cut -d "]" -f 1 \
	    | while read section
	do
	    grep -q "^$section$" $TMPINI.sections && continue
	    echo $section >> $TMPINI.sections.new
	done
	if [ -f "$TMPINI.sections.new" ]
	then
	    cat $TMPINI.sections.new $TMPINI.sections > $TMPINI.sections.updated 
	    mv $TMPINI.sections.updated $TMPINI.sections
	    rm -f $TMPINI.sections.new
	fi
    done
    cat $TMPINI.sections
    rm -f $TMPINI.sections
    return
}

ini.load.all ()
{    
    echo reading $ini_pÃ¢rsed
    ini.list.sections ini_parsed
    SAVED_IFS=$IFS
    IFS=' '$'\n'

    IFS=$SAVED_IFS
    return

    fun="$(declare -F)"
    fun="${fun//declare -f/}"
    for f in $fun; do
	echo "load $f" >&2
        [ "${f#ini.section}" == "${f}" ] && continue
	eval $f
    done
    IFS=$SAVED_IFS
}

ini.write ()
{
    [ "$1" = "-a" ] && APPEND=yes && shift || unset APPEND
    SAVED_IFS=$IFS
    IFS=' '$'\n'
    fun="$(declare -F)"
    fun="${fun//declare -f/}"
    for f in $fun; do
        [ "${f#ini.section}" == "${f}" ] && continue
	[ "$1" ] && [ "$f" != "ini.section.$1" ] && continue
#        item="$(declare -f ${f})"
        item="$(declare -f ${f} | sed -e 's/\\${.*}/BRACE/g' -e "s/=/%3D/g" -e "s/%3D/=/")"
        item="${item##*[^\\]\{}"
        item="${item%\}}"
#        item="${item//=*;/}"
#        vars="${item//=*/}"
 	vars="$item"
        [ ! "$APPEND" ] && echo "[${f#ini.section.}]"
	for var in $vars; do
	    echo "$var" | grep -q "=" || continue
	    var=$(echo $var | sed -e "s/=/%3D/g" -e "s/%3D/=/") 
	    var="${var%=*}"
            echo "$TAB"$var=\"${!var}\" | grep -v ');*=""'
        done | sed 's/${/$\\{/g' > $TMPINI.vars
	eval $f
	. $TMPINI.vars
	rm -f $TMPINI.vars
        for var in $vars; do
	    echo "$var" | grep -q "=" || continue
	    var="${var%=*}"
            echo "$TAB"$var = \"${!var}\" | grep -v ');*=""'
        done | sed "s/\$\\\{/$\{/"
    done
    IFS=$SAVED_IFS
}

ini.merge()
{
    [ "$2" ] || return
    msection=$1; shift
#    log "merging section $msection"
#    log "     from files ini_parsed"

    echo "[$msection]" >> $TMPINI.merge
    i=0
    for mfile in $@
    do
	i=$(($i + 1))
#	touch $TMPINI.merge.$i
	[ ! -f "$mfile" ] && continue
#	log processing $msection in $mfile
	ini.parse $mfile 2>/dev/null
	ini.section.$msection 2>/dev/null || continue
	ini.write -a $msection | while read line
	do
	    var=$(echo "$line" | cut -d = -f 1 \
		| sed "s/[[:blank:]]*//g")
	    egrep -v "^[[:blank:]]*$var[[:blank:]]*=" $TMPINI.merge > $TMPINI.mergenew
	    echo "$line" >> $TMPINI.mergenew
	    mv $TMPINI.mergenew $TMPINI.merge
	done
    done
    ini.parse $TMPINI.merge && ini_parsed="$@"
    return
    ini.write $msection

#    IFS=$SAVED_IFS
    return

#    printf "" | cat $(ls $TMPINI.merge* 2>/dev/null | sort -r) 
#    echo 2>/dev/null | while read line

    ls $TMPINI.merge* | while read $mfile
    do
	cat $mfile 2>/dev/null
    done | while read line
    do
	var="${line%=*}"
	grep -q "^[[:blank:]]*$var[[:blank:]]*=" $TMPINI.merge && continue
	echo $line >> $TMPINI.merge
    done
    [ -f "$TMPINI.merge" ] || return
    ini.parse $TMPINI.merge 2>/dev/null
    ini.section.$msection 2>/dev/null
    rm -f $TMPINI.merge.*
}

ini.write.all ()
{
    [ ! "$1" ] && [ ! "$ini_parsed" ] && end 1 "You need to load one or more .ini before using write.all or supply files to load to the command"
    if [ "$1" -a "$1" != "$ini_parsed" ]
    then
	log "reload $1 (had $ini_parsed)"
    else
	log "use previously loaded $ini_parsed"
    fi
    return

    ini.list.sections $@ | while read wsection
    do
	ini.merge $wsection $@
	ini.write $wsection
    done
}
