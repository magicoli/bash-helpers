#!/bin/sh
#
# This program does nothing
#

DBPATH=/usr/local/filemaker/Databases
RETRY=10

alias fmserverd='/usr/local/filemaker/FileMaker\ Server\ 5.5/FileMaker\ Server\ Config.app/Contents/Resources/fmserverd'

PID=$$
PGM=`basename $0`
TMP=/tmp/.$PGM.$PID
LOG=/tmp/$PGM

STAMP=`date +"%Y%m%d-%H%M%S"`
ARCHIVE=~/$PGM-$STAMP

IWD=$PWD
OPTS="s:d:-:hDQ"

PAR=`echo $OPTS|sed 's/.://g'|grep -v "^$"|sed "s/\([a-zA-Z0-9]*\)/[-\\1]/g" `
PAROPT=`echo $OPTS | sed "s/-://" | sed 's/\(.\)/\\1\//g' \
    | sed 's/\(.\)\/:\//[-\\1 <value>] /g' \
    | sed "s/.\///g" `
USAGE=`echo $PGM $PAR $PAROPT "[<args>]" | sed "s/  / /g"`


help() {
    usage
    echo "      -s source path"
    echo "      -d destination path"
    echo "	-h display this help"
    echo "	-D debug mode"
    echo "	-Q quiet mode"
    echo
    echo "sorry, helpman is in a minimalist mood"
    exit 0
}

usage() {
    echo "usage: $USAGE"
}

log() {
    if [ "$LOG" ]
        then
        ERRNUM=`echo "$@" |grep "^[0-9]* "|cut -d " " -f 1`
        ERR=`echo $ERRNUM|sed "s/\([0-9]*\)/<\\1\> /"`
        [ "$ERRNUM" ] && shift
        LOGMESSAGE=$@
        LOGLINE=`date +"%b %e %H:%M:%S"`" $PGM[$$]: $ERR$LOGMESSAGE"
        [ "$LOGGING" = "yes" ] && (echo $LOGLINE >> $LOG.log)
        if [ "$ERRNUM" ]
            then
            echo "$PGM: $LOGMESSAGE ($ERRNUM)" >&2
        elif [ "$DEBUG" = "yes" ]
            then
            echo "$PGM: $LOGMESSAGE" >&2
        fi
    else
        echo "LOG variable not set"
        exit 1
    fi
}

end() {
    ERRNUM=$1
    if [ "$ERRNUM" != "" -a "$ERRNUM" = "`echo $ERRNUM|sed 's/[^0-9]//g'`" ]
        then
        ERRNUM=`expr $ERRNUM + 0`
        shift
        [ "$#" -gt 0 ]  && log "<$ERRNUM>" $@
    else
        ERRNUM=
        if [ "$#" -gt 0 ]
            then
            log $@
	elif [ "$DEBUG" = "yes" ]
	    then
	    log "End processing"
        fi
    fi
    rm -f $TMP*
    rm -f $LOG.lock
    exit $ERRNUM
}

while getopts $OPTS PARAM
  do
    case $PARAM in
	"?")
	    ERROR=1
	    ;;
	-)
	    case $OPTARG in
		help)
		    help
		    ;;
		*)
		    printf $0: illegal option -- $OPTARG
#		    ERROR=1
	    esac
	    ;;
	s)
	    printf "$PARAM set to $OPTARG\n"
	    ;;
	d)
	    printf "$PARAM set to $OPTARG\n"
	    ;;
	h)
	    help
	    ;;
	D)
#		    echo "Debug mode"
	    STDERR="&1"
	    DEBUG=yes
	    ;;
	Q)
	    STDOUT="/dev/null"
	    DEBUG=no
	            ;;
	*)
	    VALUES="$VALUES $PARAM"
	    LASTVAL=$PARAM
    esac
done 2>/dev/null

shift `expr $OPTIND - 1`

if [ $ERROR ]
then
    usage
    end "$ERROR   type '$PGM --help' for more info"
fi

if [ "$1" ]
then
    for file in "$@"
      do

##
## Check availability
##
      if [ -f "$file" ]
	  then
	  log "Processing $file"
	  db=`basename "$file"`
	  newdbpath=`cd "$(dirname "$file")"; pwd`
	  newdbfile="$newdbpath/$db"
	  newdbfolder=`basename "$newdbpath"`
	  log " from $newdbfolder ($newdbpath)"
	  log "Let's hope this is a FileMaker database"
      else
	  log "Skipping $file (does not exist)"
	  continue
      fi
      opendbfile=`find $DBPATH -name "$db"`
      if [ ! "$opendbfile" ]
	  then
	  opendbfile="$DBPATH/$newdbfolder/$db"
      fi
      if [ -f "$opendbfile" ]
	  then
	  if [ "$opendbfile" = "$newdbfile" ]
	      then
	      log "Skipping $file: can not be replaced by itself"
	      continue
	  else
	      log "$opendbfile exists... will archive it later"
	  fi
      else
	  log "$opendbfile absent, will be created"
	  opendbfolder=`dirname "$opendbfile"`
	  if [ ! -d "$opendbfolder" ]
	      then
	      mkdir -p "$opendbfolder"
	      if [ $? -ne 0 ] 
		  then
		  log "folder $opendbfolder could not be created, skipping"
		  continue
	      else
		  log "folder $opendbfolder created"
	      fi
	  fi
      fi

##
## Try to close db if it is open
##

      opendb=`fmserverd files | grep "/$db$"`
      if [ "$opendb" ]
	  then log "Closing $opendb"
	  fmserverd close "$opendb"
	  i=1
	  while [ "$opendb" ]
	    do
	    log "pass $i: $db still open"
	    i=`expr $i + 1`
	    [ $i -gt $RETRY ] && end "Could not close $db, exiting"
	    opendb=`fmserverd files | grep "/$db$"`
	  done
	  log "$db closed, continue"
      else
	  log $db not open, continue
      fi
      log processing replace

##
## Archive old db file if it exists before replacing it
##
      
      if [ -f "$opendbfile" ]
	  then
	  log Archiving to $ARCHIVE.tar
	  tar -rvf "$ARCHIVE.tar" "$opendbfile" >/dev/null 2>&1
	  RESULT=$?
	  if [ $RESULT -ne 0 ] 
	      then
	      end 3 "error $RESULT while archiving, exit"
	  fi
      fi
      
##
## Now copy new file to the good location
##

      log "At least, copying $db"
      log " >  cp"
      log " >      $newdbfile" 
      log " >     $opendbfile"
      cp -fp "$newdbfile" "$opendbfile"

      RESULT=$?
      if [ $RESULT -ne 0 ]
	  then
	  end 4 "error while copying file, exit"
      fi

      log "$db copied from $newdbfolder"

##
## Copy successfull, reopen database
##

      if [ "$opendbfile" ]
	  then
	  log now bringing back $opendbfile to live
	  fmserverd open $opendbfile
	  opendb=`fmserverd files | grep "/$db$"`
	  i=1
	  while [ ! "$opendb" ]
	    do
	    log "pass $i: $db still closed"
	    i=`expr $i + 1`
	    [ $i -gt $RETRY ] && end "Could not stat $db open status, exiting"
	    opendb=`fmserverd files | grep "/$db$"`
	  done
	  log $db up and running
      else
	  end "$db file not found, exiting"
      fi
    done
fi

end

