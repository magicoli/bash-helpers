#!/bin/sh
#
# This program does nothing
#

DEBUG=yes
LOGGING=yes

### DBTYPE can be sql or text
DBTYPE=sql

DB=cata


PID=$$
PGM=`basename $0`
TMP=/tmp/.$PGM.$PID
LOG=/tmp/$PGM
DATA="$HOME/.$PGM"
SQL="psql $DB -qt"

OPTS="pthd:e:-:"
SYNTAX=`echo $OPTS|sed "s/-://g"|sed "s/\(.*\)/[-\\1] [<args>]/g"|sed "s/\(.\):/] [-\\1 <value>/g"`
#sed "s/\(.\)/-\\1 /g"|sed "s/-:/<value>/g"
USAGE="$PGM $SYNTAX"


help() {
    usage
    echo
    echo "	-h display this help"
    echo "	-d debug mode"
    echo "	-q quiet mode"
    echo
    echo "sorry, helpman is in a minimalist mood"
}

usage() {
    echo "usage: $PGM $SYNTAX"
}

log() {
    if [ "$LOG" ]
	then
	ERRNUM=`echo "$@" |grep "^[0-9]* "|cut -d " " -f 1`
	ERR=`echo $ERRNUM|sed "s/\([0-9]*\)/<\\1\> /"`
	[ "$ERRNUM" ] && shift
	LOGMESSAGE=$@
	LOGLINE=`date +"%b %e %H:%M:%S"`" $PGM[$$]: $ERR$LOGMESSAGE"
	[ "$LOGGING" = "yes" ] && (echo $LOGLINE >> $LOG.log)
	if [ "$ERRNUM" ] 
	    then
	    echo "$PGM: $LOGMESSAGE ($ERRNUM)" >&2 
	elif [ "$DEBUG" = "yes" ]
	    then
	    echo "$PGM: $LOGMESSAGE" >&2
	fi
    else
	echo "LOG variable not set"
	exit 1
    fi
}

end() {
    ERRNUM=$1
    if [ "$ERRNUM" != "" -a "$ERRNUM" = "`echo $ERRNUM|sed 's/[^0-9]//g'`" ]
        then
        ERRNUM=`expr $ERRNUM + 0`
        shift
        [ "$#" -gt 0 ]  && log "<$ERRNUM>" $@
    else
        ERRNUM=
        if [ "$#" -gt 0 ]
	    then
	    log $@
        fi
    fi
    rm -f $TMP*
    rm -f $LOG.lock
    chmod -f 666 $LOG*
    if [ "$DEBUG" = "yes" ]
        then
        log "End processing"
    fi
    exit $ERRNUM
}

sql() {
    (
	echo "$@"
	echo ";"
	)|$SQL|grep -v "^$"|grep -v "^ $"
}


while getopts $OPTS PARAM
  do
    case $PARAM in
	"?")
	    ERROR=1
	    ;;
	-)
	    case $OPTARG in
		help)
		    help
		    ;;
		*)
		    printf $0: illegal option -- $OPTARG
#		    usage
	    esac
	    ;;
	d)
	    DAY=$OPTARG
	    ;;
	e)
	    END=$OPTARG
	    ;;
	t)
	    DBTYPE=text
	    ;;
	p)
	    DBTYPE=sql
	    ;;
	h)
	    help
	    ;;
	d)
#		    echo "Debug mode"
	    STDERR="&1"
	    ;;
	q)
	    STDOUT="/dev/null"
	            ;;
	*)
	    VALUES="$VALUES $PARAM"
	    LASTVAL=$PARAM
    esac
done

shift `expr $OPTIND - 1`


if [ $ERROR ]
then
    usage
    rm -f $TMP*
    end $ERROR
fi

#######################################
## Guess begin and end if not specified

if [ ! "$DAY" ] 
    then
    DAY=`date -d "-1 day"`
fi

date -d "$DAY" >/dev/null 2>/dev/null || end invalid date \""$DAY"\"

processday=`date -d "$DAY" +%Y/%m/%d`

if [ ! "$END" ]
    then
    END=`date -d "$processday" +%Y/%m/01`
fi

date -d "$END" >/dev/null 2>/dev/null || end invalid end date \""$END"\"

endprocess=`date -d "$END" +%Y/%m/%d`

if [ `date +%s -d "$processday"` -gt `date +%s -d "$endprocess"` ]
    then
    DATEBEGIN=$endprocess
    DATEEND=$processday
else
    DATEBEGIN=$processday
    DATEEND=$endprocess
fi


###########################################################
## Check last data stored in database and adjust begin date

nexttoprocess=$DATEBEGIN

if [ "$DBTYPE" = "sql" ]
    then
    lastprocessed=`sql "select max(action_begin) from events"`
    if [ "$lastprocessed" ]
	then
	nexttoprocess=`date -d "$lastprocessed +1 day" +%Y/%m/%d`
    fi
else
    if [ -f "$DATA.data" ]
	then
	lastprocessed=`tail -1 $DATA.data |cut -d " " -f 1`
	nexttoprocess=`date -d "$lastprocessed +1 day" +%Y/%m/%d`
    fi
fi

if [ `date -d "$nexttoprocess" +%s` -gt `date -d "$DATEEND" +%s` ]
    then
    log was about to process dates from $DATEBEGIN to $DATEEND
    log next to process: $nexttoprocess
    end
elif [ `date -d "$lastprocessed" +%s` -gt `date -d "$DATEBEGIN" +%s` ]
    then
    DATEBEGIN=$nexttoprocess
fi

endnum=`date -d "$DATEEND" +%s`
process=$DATEBEGIN
processnum=`date -d "$process" +%s`

################################################
## OK now, we can begin processing data

log processing dates from $DATEBEGIN to $DATEEND

while [ "$processnum" -le "$endnum" ]
do
  log processing $process
  datesed=`echo $process|sed "s/\//\\\\\\\\\//g"`
  lynx -dump "http://netview.sopres.be/intranet/f/1/4/001.asp?trinome=OVH&DateToUse=$process"\
      |grep -A 20 "Begin"|grep -B 20 Worked|grep "\["|grep -v "\[BUTTON"\
      |sed s/^/"$datesed"/\
      |sed "s/[_\.\[]//g"|sed "s/\]//g" > $TMP.line
  DATECOUNT=`cat $TMP.line|wc -l`
  if [ $DATECOUNT -gt 0 ]
      then
      if [ "$DBTYPE" = "text" ]
	  then
	  cat $TMP.line >> $DATA.data
      else
	  cat $TMP.line |while read date begin end action comment
	do 
	    if [ `sql "select * from events 
		    where action_begin='$date $begin'
		    and action_end='$date $end';"|wc -l` -eq 0 ]
		then
		sql "insert into events(action_begin, action_end, client_nick, job_nick, action_nick)
	                values ('$date $begin', '$date $end', 'clpb', 'regie', '$action')"
	    fi
	  done
      fi
      log $process: $DATECOUNT lines
  fi
  let i=$i+1
  process=`date -d "$DATEBEGIN +$i day" +%Y/%m/%d` 
  processnum=`date -d "$process" +%s`
done

rm -f $TMP*
